"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/dashboard/page",{

/***/ "(app-pages-browser)/./src/services/taskService.ts":
/*!*************************************!*\
  !*** ./src/services/taskService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   taskService: () => (/* binding */ taskService)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"(app-pages-browser)/./src/config/index.ts\");\n/* harmony import */ var _utils_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/auth */ \"(app-pages-browser)/./src/utils/auth.ts\");\n\n\nclass TaskService {\n    /**\r\n   * Get all tasks\r\n   */ async getAllTasks() {\n        try {\n            console.log('TaskService: Fetching all tasks');\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.tasks;\n            } else {\n                throw new Error(data.message || 'Failed to fetch tasks');\n            }\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Get tasks for the current user\r\n   */ async getUserTasks(id) {\n        try {\n            console.log('TaskService: Fetching tasks for user ID:', id);\n            const headers = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)();\n            console.log('TaskService: Request headers:', headers);\n            console.log('TaskService: Request URL:', \"\".concat(this.baseUrl).concat(this.endpoints.GET_USER_TASKS_BY_ID.replace(':userId', id)));\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_USER_TASKS_BY_ID.replace(':userId', id)), {\n                method: 'GET',\n                headers\n            });\n            console.log('TaskService: Response status:', response.status);\n            console.log('TaskService: Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                console.error('TaskService: HTTP error:', response.status, response.statusText);\n            }\n            const data = await response.json();\n            console.log(\"TaskService: Full response data:\", data);\n            if (response.ok && data.success) {\n                // Handle different response structures\n                let tasks = [];\n                if (data.data && Array.isArray(data.data.tasks)) {\n                    tasks = data.data.tasks;\n                } else if (data.data && Array.isArray(data.data)) {\n                    tasks = data.data;\n                } else if (Array.isArray(data.tasks)) {\n                    tasks = data.tasks;\n                } else if (Array.isArray(data)) {\n                    tasks = data;\n                }\n                console.log('TaskService: Extracted tasks:', tasks);\n                return tasks;\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || 'Failed to fetch tasks');\n            }\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Get a single task by ID\r\n   */ async getTaskById(id) {\n        try {\n            console.log('TaskService: Fetching task by ID:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL, \"/\").concat(id), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            console.log('TaskService: Response status:', response.status);\n            const data = await response.json();\n            console.log(\"TaskService: Full response data:\", data);\n            if (response.ok && data.success) {\n                return data.data.task || data.data;\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || 'Failed to fetch task');\n            }\n        } catch (error) {\n            console.error('Error fetching task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Create a new task\r\n   */ async createTask(taskData) {\n        try {\n            console.log('TaskService: Creating new task:', taskData);\n            console.log('TaskService: Request URL:', \"\".concat(this.baseUrl).concat(this.endpoints.CREATE));\n            const headers = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)();\n            console.log('TaskService: Auth Headers:', headers); // Log the full headers\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.CREATE), {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(taskData)\n            });\n            console.log('TaskService: Response status:', response.status);\n            console.log('TaskService: Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                console.error('TaskService: HTTP error:', response.status, response.statusText);\n            }\n            const data = await response.json();\n            console.log('TaskService: Response data:', data);\n            if (response.ok && data.success) {\n                console.log('TaskService: Task created successfully:', data.data);\n                console.log('TaskService: Response data structure:', data);\n                console.log('TaskService: Task data type:', typeof data.data);\n                // Ensure we return a valid task object\n                const task = data.data;\n                console.log(\"ckek\", task);\n                // return task;\n                if (task && typeof task === 'object' && task._id) {\n                    console.log('TaskService: Valid task object returned:', task);\n                    return task;\n                } else {\n                    console.error('TaskService: Invalid task object in response:', task);\n                    throw new Error('Invalid task object received from server');\n                }\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || \"Failed to create task: \".concat(response.status));\n            }\n        } catch (error) {\n            console.error('Error creating task:', error);\n            // Log the full error details\n            if (error instanceof Error) {\n                console.error('Error details:', {\n                    message: error.message,\n                    stack: error.stack\n                });\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Delete a task\r\n   */ async deleteTask(id) {\n        try {\n            console.log('TaskService: Deleting task:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.DELETE, \"/\").concat(id), {\n                method: 'DELETE',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            if (!response.ok) {\n                throw new Error(\"Delete request failed with status: \".concat(response.status));\n            }\n            const data = await response.json();\n            if (data.success) {\n                console.log('TaskService: Task successfully deleted');\n                return true;\n            } else {\n                throw new Error(data.message || 'Failed to delete task');\n            }\n        } catch (error) {\n            console.error('Error deleting task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Search tasks by title or description\r\n   */ /**\r\n   * Update a task\r\n   */ async updateTask(id, updateData) {\n        try {\n            console.log('TaskService: Updating task:', id, updateData);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/\").concat(id), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify(updateData)\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.task;\n            } else {\n                throw new Error(data.message || 'Failed to update task');\n            }\n        } catch (error) {\n            console.error('Error updating task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Reorder tasks for a user (best-effort).\r\n   * Sends an ordered array of task IDs to the server. Server must support PATCH /tasks/reorder\r\n   */ async reorderTasks(userId, orderedIds) {\n        try {\n            console.log('TaskService: Reordering tasks for user:', userId, orderedIds);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/reorder\"), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify({\n                    userId,\n                    orderedIds\n                })\n            });\n            if (!response.ok) {\n                console.warn('TaskService: reorderTasks HTTP error:', response.status);\n            }\n            const data = await response.json();\n            if (response.ok && data && data.success) {\n                return true;\n            }\n            console.warn('TaskService: reorderTasks API did not report success:', data);\n            return false;\n        } catch (error) {\n            console.error('Error reordering tasks:', error);\n            return false;\n        }\n    }\n    constructor(){\n        this.baseUrl = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.BASE_URL;\n        this.endpoints = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.ENDPOINTS.TASKS;\n    }\n}\n// Export a singleton instance\nconst taskService = new TaskService();\n// Export the class for potential custom instances\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TaskService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90YXNrU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ1E7QUFnRC9DLE1BQU1FO0lBSUo7O0dBRUMsR0FDRCxNQUFNQyxjQUErQjtRQUNuQyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFrQixPQUFmLElBQUksQ0FBQ0MsT0FBTyxFQUEwQixPQUF2QixJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTyxHQUFJO2dCQUN2RUMsUUFBUTtnQkFDUkMsU0FBU1gsMkRBQWNBO1lBQ3pCO1lBRUEsTUFBTVksT0FBc0IsTUFBTVAsU0FBU1EsSUFBSTtZQUUvQyxJQUFJUixTQUFTUyxFQUFFLElBQUlGLEtBQUtHLE9BQU8sRUFBRTtnQkFDL0IsT0FBT0gsS0FBS0EsSUFBSSxDQUFDSSxLQUFLO1lBQ3hCLE9BQU87Z0JBQ0wsTUFBTSxJQUFJQyxNQUFNTCxLQUFLTSxPQUFPLElBQUk7WUFDbEM7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZGhCLFFBQVFnQixLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQU1ELE1BQU1DLGFBQWFDLEVBQVUsRUFBbUI7UUFDOUMsSUFBSTtZQUNGbEIsUUFBUUMsR0FBRyxDQUFDLDRDQUE0Q2lCO1lBQ3hELE1BQU1WLFVBQVVYLDJEQUFjQTtZQUM5QkcsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ087WUFDN0NSLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkIsR0FBa0IsT0FBZixJQUFJLENBQUNHLE9BQU8sRUFBOEQsT0FBM0QsSUFBSSxDQUFDQyxTQUFTLENBQUNjLG9CQUFvQixDQUFDQyxPQUFPLENBQUMsV0FBV0Y7WUFFbEgsTUFBTWhCLFdBQVcsTUFBTUMsTUFBTSxHQUFrQixPQUFmLElBQUksQ0FBQ0MsT0FBTyxFQUE4RCxPQUEzRCxJQUFJLENBQUNDLFNBQVMs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Q0FBQyx5Q0FBeUM1QyxTQUFTbUIsTUFBTTtZQUN2RTtZQUVBLE1BQU1aLE9BQVksTUFBTVAsU0FBU1EsSUFBSTtZQUNyQyxJQUFJUixTQUFTUyxFQUFFLElBQUlGLFFBQVFBLEtBQUtHLE9BQU8sRUFBRTtnQkFDdkMsT0FBTztZQUNUO1lBRUFaLFFBQVE4QyxJQUFJLENBQUMseURBQXlEckM7WUFDdEUsT0FBTztRQUNULEVBQUUsT0FBT08sT0FBTztZQUNkaEIsUUFBUWdCLEtBQUssQ0FBQywyQkFBMkJBO1lBQ3pDLE9BQU87UUFDVDtJQUNGOzthQTdRUVosVUFBVVIsK0NBQVVBLENBQUNtRCxRQUFRO2FBQzdCMUMsWUFBWVQsK0NBQVVBLENBQUNvRCxTQUFTLENBQUNDLEtBQUs7O0FBNlFoRDtBQUVBLDhCQUE4QjtBQUN2QixNQUFNQyxjQUFjLElBQUlwRCxjQUFjO0FBRTdDLGtEQUFrRDtBQUNsRCxpRUFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBcnBhXFxEZXNrdG9wXFx0YXNrLW1hbmFnZXJDbGllbnRcXHNyY1xcc2VydmljZXNcXHRhc2tTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9DT05GSUcgfSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQgeyBnZXRBdXRoSGVhZGVycyB9IGZyb20gJy4uL3V0aWxzL2F1dGgnO1xyXG5cclxuLy8gVGFzayBpbnRlcmZhY2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFzayB7XHJcbiAgX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGR1ZURhdGU6IHN0cmluZztcclxuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcclxuICBzdGF0dXM6ICd0b2RvJyB8ICdpbi1wcm9ncmVzcycgfCAnY29tcGxldGVkJztcclxuICBjcmVhdGVkQXQ6IHN0cmluZztcclxuICB1cGRhdGVkQXQ6IHN0cmluZztcclxuICBjcmVhdGVkQnk6IHN0cmluZztcclxuICBpc1N5bmNpbmc/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVRhc2tEYXRhIHtcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgZHVlRGF0ZTogc3RyaW5nO1xyXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xyXG4gIHN0YXR1czogJ3RvZG8nIHwgJ2luLXByb2dyZXNzJyB8ICdjb21wbGV0ZWQnO1xyXG4gIHVzZXJJZDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVRhc2tEYXRhIGV4dGVuZHMgUGFydGlhbDxDcmVhdGVUYXNrRGF0YT4ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFza3NSZXNwb25zZSB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBkYXRhOiB7XHJcbiAgICB0YXNrczogVGFza1tdO1xyXG4gIH07XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYXNrUmVzcG9uc2Uge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZGF0YToge1xyXG4gICAgdGFzazogVGFzaztcclxuICB9O1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXBpUmVzcG9uc2Uge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxufVxyXG5cclxuY2xhc3MgVGFza1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgYmFzZVVybCA9IEFQSV9DT05GSUcuQkFTRV9VUkw7XHJcbiAgcHJpdmF0ZSBlbmRwb2ludHMgPSBBUElfQ09ORklHLkVORFBPSU5UUy5UQVNLUztcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCB0YXNrc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldEFsbFRhc2tzKCk6IFByb21pc2U8VGFza1tdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IEZldGNoaW5nIGFsbCB0YXNrcycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkdFVF9BTEx9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVyczogZ2V0QXV0aEhlYWRlcnMoKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBUYXNrc1Jlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmRhdGEudGFza3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIHRhc2tzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRhc2tzOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGFza3MgZm9yIHRoZSBjdXJyZW50IHVzZXJcclxuICAgKi9cclxuIFxyXG5cclxuXHJcblxyXG5cclxuICBhc3luYyBnZXRVc2VyVGFza3MoaWQ6IHN0cmluZyk6IFByb21pc2U8VGFza1tdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IEZldGNoaW5nIHRhc2tzIGZvciB1c2VyIElEOicsIGlkKTtcclxuICAgICAgY29uc3QgaGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVxdWVzdCBoZWFkZXJzOicsIGhlYWRlcnMpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlcXVlc3QgVVJMOicsIGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkdFVF9VU0VSX1RBU0tTX0JZX0lELnJlcGxhY2UoJzp1c2VySWQnLCBpZCl9YCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkdFVF9VU0VSX1RBU0tTX0JZX0lELnJlcGxhY2UoJzp1c2VySWQnLCBpZCl9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEhUVFAgZXJyb3I6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGF0YTogYW55ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRhc2tTZXJ2aWNlOiBGdWxsIHJlc3BvbnNlIGRhdGE6XCIsIGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcmVzcG9uc2Ugc3RydWN0dXJlc1xyXG4gICAgICAgIGxldCB0YXNrczogVGFza1tdID0gW107XHJcbiAgICAgICAgaWYgKGRhdGEuZGF0YSAmJiBBcnJheS5pc0FycmF5KGRhdGEuZGF0YS50YXNrcykpIHtcclxuICAgICAgICAgIHRhc2tzID0gZGF0YS5kYXRhLnRhc2tzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5kYXRhICYmIEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKSkge1xyXG4gICAgICAgICAgdGFza3MgPSBkYXRhLmRhdGE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEudGFza3MpKSB7XHJcbiAgICAgICAgICB0YXNrcyA9IGRhdGEudGFza3M7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICB0YXNrcyA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogRXh0cmFjdGVkIHRhc2tzOicsIHRhc2tzKTtcclxuICAgICAgICByZXR1cm4gdGFza3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEFQSSBlcnJvciByZXNwb25zZTonLCBkYXRhKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGFza3MnKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBzaW5nbGUgdGFzayBieSBJRFxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFRhc2tCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFRhc2s+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogRmV0Y2hpbmcgdGFzayBieSBJRDonLCBpZCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuR0VUX0FMTH0vJHtpZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IGFueSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coXCJUYXNrU2VydmljZTogRnVsbCByZXNwb25zZSBkYXRhOlwiLCBkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5kYXRhLnRhc2sgfHwgZGF0YS5kYXRhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBBUEkgZXJyb3IgcmVzcG9uc2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIHRhc2snKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IHRhc2tcclxuICAgKi9cclxuICBhc3luYyBjcmVhdGVUYXNrKHRhc2tEYXRhOiBDcmVhdGVUYXNrRGF0YSk6IFByb21pc2U8VGFzaz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBDcmVhdGluZyBuZXcgdGFzazonLCB0YXNrRGF0YSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVxdWVzdCBVUkw6JywgYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuQ1JFQVRFfWApO1xyXG4gICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QXV0aEhlYWRlcnMoKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBBdXRoIEhlYWRlcnM6JywgaGVhZGVycyk7IC8vIExvZyB0aGUgZnVsbCBoZWFkZXJzXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkNSRUFURX1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0YXNrRGF0YSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBIVFRQIGVycm9yOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcclxuXHJcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFRhc2sgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YS5kYXRhKTtcclxuICAgICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIGRhdGEgc3RydWN0dXJlOicsIGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVGFzayBkYXRhIHR5cGU6JywgdHlwZW9mIGRhdGEuZGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRW5zdXJlIHdlIHJldHVybiBhIHZhbGlkIHRhc2sgb2JqZWN0XHJcbiAgICAgICAgY29uc3QgdGFzayA9IGRhdGEuZGF0YTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNrZWtcIix0YXNrKVxyXG4gICAgICAgIC8vIHJldHVybiB0YXNrO1xyXG4gICAgICAgIGlmICh0YXNrICYmIHR5cGVvZiB0YXNrID09PSAnb2JqZWN0JyAmJiB0YXNrLl9pZCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBWYWxpZCB0YXNrIG9iamVjdCByZXR1cm5lZDonLCB0YXNrKTtcclxuICAgICAgICAgIHJldHVybiB0YXNrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrU2VydmljZTogSW52YWxpZCB0YXNrIG9iamVjdCBpbiByZXNwb25zZTonLCB0YXNrKTtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXNrIG9iamVjdCByZWNlaXZlZCBmcm9tIHNlcnZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrU2VydmljZTogQVBJIGVycm9yIHJlc3BvbnNlOicsIGRhdGEpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgYEZhaWxlZCB0byBjcmVhdGUgdGFzazogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHRhc2s6JywgZXJyb3IpO1xyXG4gICAgICAvLyBMb2cgdGhlIGZ1bGwgZXJyb3IgZGV0YWlsc1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6Jywge1xyXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiBcclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgdGFza1xyXG4gICAqL1xyXG4gIGFzeW5jIGRlbGV0ZVRhc2soaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBEZWxldGluZyB0YXNrOicsIGlkKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5ERUxFVEV9LyR7aWR9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgaGVhZGVyczogZ2V0QXV0aEhlYWRlcnMoKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWxldGUgcmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBBcGlSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFRhc2sgc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQnKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVsZXRlIHRhc2snKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VhcmNoIHRhc2tzIGJ5IHRpdGxlIG9yIGRlc2NyaXB0aW9uXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhIHRhc2tcclxuICAgKi9cclxuICBhc3luYyB1cGRhdGVUYXNrKGlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVwZGF0ZVRhc2tEYXRhKTogUHJvbWlzZTxUYXNrPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFVwZGF0aW5nIHRhc2s6JywgaWQsIHVwZGF0ZURhdGEpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLlVQREFURX0vJHtpZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlRGF0YSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgZGF0YTogVGFza1Jlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmRhdGEudGFzaztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHRhc2snKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVvcmRlciB0YXNrcyBmb3IgYSB1c2VyIChiZXN0LWVmZm9ydCkuXHJcbiAgICogU2VuZHMgYW4gb3JkZXJlZCBhcnJheSBvZiB0YXNrIElEcyB0byB0aGUgc2VydmVyLiBTZXJ2ZXIgbXVzdCBzdXBwb3J0IFBBVENIIC90YXNrcy9yZW9yZGVyXHJcbiAgICovXHJcbiAgYXN5bmMgcmVvcmRlclRhc2tzKHVzZXJJZDogc3RyaW5nLCBvcmRlcmVkSWRzOiBzdHJpbmdbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZW9yZGVyaW5nIHRhc2tzIGZvciB1c2VyOicsIHVzZXJJZCwgb3JkZXJlZElkcyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuVVBEQVRFfS9yZW9yZGVyYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCBvcmRlcmVkSWRzIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1Rhc2tTZXJ2aWNlOiByZW9yZGVyVGFza3MgSFRUUCBlcnJvcjonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBhbnkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLndhcm4oJ1Rhc2tTZXJ2aWNlOiByZW9yZGVyVGFza3MgQVBJIGRpZCBub3QgcmVwb3J0IHN1Y2Nlc3M6JywgZGF0YSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlb3JkZXJpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnQgYSBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHRhc2tTZXJ2aWNlID0gbmV3IFRhc2tTZXJ2aWNlKCk7XHJcblxyXG4vLyBFeHBvcnQgdGhlIGNsYXNzIGZvciBwb3RlbnRpYWwgY3VzdG9tIGluc3RhbmNlc1xyXG5leHBvcnQgZGVmYXVsdCBUYXNrU2VydmljZTsiXSwibmFtZXMiOlsiQVBJX0NPTkZJRyIsImdldEF1dGhIZWFkZXJzIiwiVGFza1NlcnZpY2UiLCJnZXRBbGxUYXNrcyIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwiYmFzZVVybCIsImVuZHBvaW50cyIsIkdFVF9BTEwiLCJtZXRob2QiLCJoZWFkZXJzIiwiZGF0YSIsImpzb24iLCJvayIsInN1Y2Nlc3MiLCJ0YXNrcyIsIkVycm9yIiwibWVzc2FnZSIsImVycm9yIiwiZ2V0VXNlclRhc2tzIiwiaWQiLCJHRVRfVVNFUl9UQVNLU19CWV9JRCIsInJlcGxhY2UiLCJzdGF0dXMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJzdGF0dXNUZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0VGFza0J5SWQiLCJ0YXNrIiwiY3JlYXRlVGFzayIsInRhc2tEYXRhIiwiQ1JFQVRFIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJfaWQiLCJzdGFjayIsImRlbGV0ZVRhc2siLCJERUxFVEUiLCJ1cGRhdGVUYXNrIiwidXBkYXRlRGF0YSIsIlVQREFURSIsInJlb3JkZXJUYXNrcyIsInVzZXJJZCIsIm9yZGVyZWRJZHMiLCJ3YXJuIiwiQkFTRV9VUkwiLCJFTkRQT0lOVFMiLCJUQVNLUyIsInRhc2tTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/taskService.ts\n"));

/***/ })

});
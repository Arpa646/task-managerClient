"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/dashboard/page",{

/***/ "(app-pages-browser)/./src/services/taskService.ts":
/*!*************************************!*\
  !*** ./src/services/taskService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   taskService: () => (/* binding */ taskService)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"(app-pages-browser)/./src/config/index.ts\");\n/* harmony import */ var _utils_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/auth */ \"(app-pages-browser)/./src/utils/auth.ts\");\n\n\nclass TaskService {\n    /**\r\n   * Get all tasks\r\n   */ async getAllTasks() {\n        try {\n            console.log('TaskService: Fetching all tasks');\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.tasks;\n            } else {\n                throw new Error(data.message || 'Failed to fetch tasks');\n            }\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Get tasks for the current user\r\n   */ async getUserTasks() {\n        try {\n            const url = \"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL);\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                cache: \"no-store\"\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error: \".concat(response.status));\n            }\n            const data = await response.json();\n            // ðŸ‘‡ SIMPLE response handling\n            return Array.isArray(data.results) ? data.results : [];\n        } catch (error) {\n            console.error(\"Error fetching tasks:\", error);\n            throw new Error(\"Failed to fetch tasks.\");\n        }\n    }\n    /**\r\n   * Get a single task by ID\r\n   */ async getTaskById(id) {\n        try {\n            console.log('TaskService: Fetching task by ID:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL, \"/\").concat(id), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            console.log('TaskService: Response status:', response.status);\n            const data = await response.json();\n            console.log(\"TaskService: Full response data:\", data);\n            if (response.ok && data.success) {\n                return data.data.task || data.data;\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || 'Failed to fetch task');\n            }\n        } catch (error) {\n            console.error('Error fetching task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Create a new task\r\n   */ async createTask(taskData) {\n        try {\n            console.log('TaskService: Creating new task:', taskData);\n            const endpoint = \"\".concat(this.tasksBaseUrl).concat(this.endpoints.CREATE);\n            console.log('TaskService: Request URL:', endpoint);\n            // Prepare FormData payload as required by the API\n            const formData = new FormData();\n            formData.append('title', taskData.title);\n            var _taskData_description;\n            formData.append('description', (_taskData_description = taskData.description) !== null && _taskData_description !== void 0 ? _taskData_description : '');\n            // Map internal priority to API expected values (e.g., medium -> moderate)\n            const priorityMap = {\n                low: 'low',\n                medium: 'moderate',\n                high: 'high'\n            };\n            const mappedPriority = priorityMap[taskData.priority] || taskData.priority || 'moderate';\n            formData.append('priority', mappedPriority);\n            if (taskData.dueDate) {\n                const dueDate = new Date(taskData.dueDate);\n                if (!Number.isNaN(dueDate.getTime())) {\n                    formData.append('todo_date', dueDate.toISOString().split('T')[0]);\n                } else {\n                    formData.append('todo_date', taskData.dueDate);\n                }\n            }\n            const token = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthToken)();\n            const headers = {};\n            if (token) {\n                headers['Authorization'] = \"Bearer \".concat(token);\n            }\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers,\n                body: formData\n            });\n            console.log('TaskService: Response status:', response.status);\n            console.log('TaskService: Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                console.error('TaskService: HTTP error:', response.status, response.statusText);\n            }\n            const data = await response.json();\n            console.log('TaskService: Response data:', data);\n            if (response.ok) {\n                const createdTask = data.data || data.todo || data.task || data;\n                console.log('TaskService: Task created successfully:', createdTask);\n                if (createdTask && typeof createdTask === 'object') {\n                    return createdTask;\n                }\n                throw new Error('Invalid task object received from server');\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || \"Failed to create task: \".concat(response.status));\n            }\n        } catch (error) {\n            console.error('Error creating task:', error);\n            // Log the full error details\n            if (error instanceof Error) {\n                console.error('Error details:', {\n                    message: error.message,\n                    stack: error.stack\n                });\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Delete a task\r\n   */ async deleteTask(id) {\n        try {\n            console.log('TaskService: Deleting task:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.DELETE, \"/\").concat(id), {\n                method: 'DELETE',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            if (!response.ok) {\n                throw new Error(\"Delete request failed with status: \".concat(response.status));\n            }\n            const data = await response.json();\n            if (data.success) {\n                console.log('TaskService: Task successfully deleted');\n                return true;\n            } else {\n                throw new Error(data.message || 'Failed to delete task');\n            }\n        } catch (error) {\n            console.error('Error deleting task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Search tasks by title or description\r\n   */ /**\r\n   * Update a task\r\n   */ async updateTask(id, updateData) {\n        try {\n            console.log('TaskService: Updating task:', id, updateData);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/\").concat(id), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify(updateData)\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.task;\n            } else {\n                throw new Error(data.message || 'Failed to update task');\n            }\n        } catch (error) {\n            console.error('Error updating task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Reorder tasks for a user (best-effort).\r\n   * Sends an ordered array of task IDs to the server. Server must support PATCH /tasks/reorder\r\n   */ async reorderTasks(userId, orderedIds) {\n        try {\n            console.log('TaskService: Reordering tasks for user:', userId, orderedIds);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/reorder\"), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify({\n                    userId,\n                    orderedIds\n                })\n            });\n            if (!response.ok) {\n                console.warn('TaskService: reorderTasks HTTP error:', response.status);\n            }\n            const data = await response.json();\n            if (response.ok && data && data.success) {\n                return true;\n            }\n            console.warn('TaskService: reorderTasks API did not report success:', data);\n            return false;\n        } catch (error) {\n            console.error('Error reordering tasks:', error);\n            return false;\n        }\n    }\n    constructor(){\n        this.baseUrl = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.BASE_URL;\n        this.tasksBaseUrl = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.TASKS_BASE_URL || _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.BASE_URL;\n        this.endpoints = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.ENDPOINTS.TASKS;\n    }\n}\n// Export a singleton instance\nconst taskService = new TaskService();\n// Export the class for potential custom instances\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TaskService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90YXNrU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ3NCO0FBZ0Q3RCxNQUFNRztJQUtKOztHQUVDLEdBQ0QsTUFBTUMsY0FBK0I7UUFDbkMsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBa0IsT0FBZixJQUFJLENBQUNDLE9BQU8sRUFBMEIsT0FBdkIsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE9BQU8sR0FBSTtnQkFDdkVDLFFBQVE7Z0JBQ1JDLFNBQVNaLDJEQUFjQTtZQUN6QjtZQUVBLE1BQU1hLE9BQXNCLE1BQU1QLFNBQVNRLElBQUk7WUFFL0MsSUFBSVIsU0FBU1MsRUFBRSxJQUFJRixLQUFLRyxPQUFPLEVBQUU7Z0JBQy9CLE9BQU9ILEtBQUtBLElBQUksQ0FBQ0ksS0FBSztZQUN4QixPQUFPO2dCQUNMLE1BQU0sSUFBSUMsTUFBTUwsS0FBS00sT0FBTyxJQUFJO1lBQ2xDO1FBQ0YsRUFBRSxPQUFPQyxPQUFPO1lBQ2RoQixRQUFRZ0IsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FNRCxNQUFNQyxlQUFnQztRQUNwQyxJQUFJO1lBQ0YsTUFBTUMsTUFBTSxHQUFrQixPQUFmLElBQUksQ0FBQ2QsT0FBTyxFQUEwQixPQUF2QixJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTztZQUVwRCxNQUFNSixXQUFXLE1BQU1DLE1BQU1lLEtBQUs7Z0JBQ2hDWCxRQUFRO2dCQUNSQyxTQUFTWiwyREFBY0E7Z0JBQ3ZCdUIsT0FBTztZQUNUO1lBRUEsSUFBSSxDQUFDakIsU0FBU1MsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlHLE1BQU0sZUFBK0IsT0FBaEJaLFNBQVNrQixNQUFNO1lBQ2hEO1lBRUEsTUFBTVgsT0FBTyxNQUFNUCxTQUFTUSxJQUFJO1lBRWhDLDhCQUE4QjtZ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V0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBcnBhXFxEZXNrdG9wXFx0YXNrLW1hbmFnZXJDbGllbnRcXHNyY1xcc2VydmljZXNcXHRhc2tTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9DT05GSUcgfSBmcm9tICcuLi9jb25maWcnO1xyXG5pbXBvcnQgeyBnZXRBdXRoSGVhZGVycywgZ2V0QXV0aFRva2VuIH0gZnJvbSAnLi4vdXRpbHMvYXV0aCc7XHJcblxyXG4vLyBUYXNrIGludGVyZmFjZXNcclxuZXhwb3J0IGludGVyZmFjZSBUYXNrIHtcclxuICBfaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgZHVlRGF0ZTogc3RyaW5nO1xyXG4gIHByaW9yaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xyXG4gIHN0YXR1czogJ3RvZG8nIHwgJ2luLXByb2dyZXNzJyB8ICdjb21wbGV0ZWQnO1xyXG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xyXG4gIGNyZWF0ZWRCeTogc3RyaW5nO1xyXG4gIGlzU3luY2luZz86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlVGFza0RhdGEge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBkdWVEYXRlOiBzdHJpbmc7XHJcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XHJcbiAgc3RhdHVzOiAndG9kbycgfCAnaW4tcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCc7XHJcbiAgdXNlcklkOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlVGFza0RhdGEgZXh0ZW5kcyBQYXJ0aWFsPENyZWF0ZVRhc2tEYXRhPiB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYXNrc1Jlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIGRhdGE6IHtcclxuICAgIHRhc2tzOiBUYXNrW107XHJcbiAgfTtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tSZXNwb25zZSB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBkYXRhOiB7XHJcbiAgICB0YXNrOiBUYXNrO1xyXG4gIH07XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBcGlSZXNwb25zZSB7XHJcbiAgc3VjY2VzczogYm9vbGVhbjtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBUYXNrU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBiYXNlVXJsID0gQVBJX0NPTkZJRy5CQVNFX1VSTDtcclxuICBwcml2YXRlIHRhc2tzQmFzZVVybCA9IEFQSV9DT05GSUcuVEFTS1NfQkFTRV9VUkwgfHwgQVBJX0NPTkZJRy5CQVNFX1VSTDtcclxuICBwcml2YXRlIGVuZHBvaW50cyA9IEFQSV9DT05GSUcuRU5EUE9JTlRTLlRBU0tTO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIHRhc2tzXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0QWxsVGFza3MoKTogUHJvbWlzZTxUYXNrW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogRmV0Y2hpbmcgYWxsIHRhc2tzJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuR0VUX0FMTH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IFRhc2tzUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2sgJiYgZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS50YXNrcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGFza3MnKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFza3M6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0YXNrcyBmb3IgdGhlIGN1cnJlbnQgdXNlclxyXG4gICAqL1xyXG4gXHJcblxyXG5cclxuXHJcblxyXG4gIGFzeW5jIGdldFVzZXJUYXNrcygpOiBQcm9taXNlPFRhc2tbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuR0VUX0FMTH1gO1xyXG4gIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXHJcbiAgICAgIH0pO1xyXG4gIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gIFxyXG4gICAgICAvLyDwn5GHIFNJTVBMRSByZXNwb25zZSBoYW5kbGluZ1xyXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkYXRhLnJlc3VsdHMpID8gZGF0YS5yZXN1bHRzIDogW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdGFza3M6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHRhc2tzLlwiKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBzaW5nbGUgdGFzayBieSBJRFxyXG4gICAqL1xyXG4gIGFzeW5jIGdldFRhc2tCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFRhc2s+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogRmV0Y2hpbmcgdGFzayBieSBJRDonLCBpZCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuR0VUX0FMTH0vJHtpZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IGFueSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coXCJUYXNrU2VydmljZTogRnVsbCByZXNwb25zZSBkYXRhOlwiLCBkYXRhKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5kYXRhLnRhc2sgfHwgZGF0YS5kYXRhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBBUEkgZXJyb3IgcmVzcG9uc2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIHRhc2snKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IHRhc2tcclxuICAgKi9cclxuICBhc3luYyBjcmVhdGVUYXNrKHRhc2tEYXRhOiBDcmVhdGVUYXNrRGF0YSk6IFByb21pc2U8VGFzaz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBDcmVhdGluZyBuZXcgdGFzazonLCB0YXNrRGF0YSk7XHJcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy50YXNrc0Jhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5DUkVBVEV9YDtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXF1ZXN0IFVSTDonLCBlbmRwb2ludCk7XHJcblxyXG4gICAgICAvLyBQcmVwYXJlIEZvcm1EYXRhIHBheWxvYWQgYXMgcmVxdWlyZWQgYnkgdGhlIEFQSVxyXG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3RpdGxlJywgdGFza0RhdGEudGl0bGUpO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2Rlc2NyaXB0aW9uJywgdGFza0RhdGEuZGVzY3JpcHRpb24gPz8gJycpO1xyXG5cclxuICAgICAgLy8gTWFwIGludGVybmFsIHByaW9yaXR5IHRvIEFQSSBleHBlY3RlZCB2YWx1ZXMgKGUuZy4sIG1lZGl1bSAtPiBtb2RlcmF0ZSlcclxuICAgICAgY29uc3QgcHJpb3JpdHlNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAgICAgbG93OiAnbG93JyxcclxuICAgICAgICBtZWRpdW06ICdtb2RlcmF0ZScsXHJcbiAgICAgICAgaGlnaDogJ2hpZ2gnLFxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBtYXBwZWRQcmlvcml0eSA9IHByaW9yaXR5TWFwW3Rhc2tEYXRhLnByaW9yaXR5XSB8fCB0YXNrRGF0YS5wcmlvcml0eSB8fCAnbW9kZXJhdGUnO1xyXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3ByaW9yaXR5JywgbWFwcGVkUHJpb3JpdHkpO1xyXG5cclxuICAgICAgaWYgKHRhc2tEYXRhLmR1ZURhdGUpIHtcclxuICAgICAgICBjb25zdCBkdWVEYXRlID0gbmV3IERhdGUodGFza0RhdGEuZHVlRGF0ZSk7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZHVlRGF0ZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3RvZG9fZGF0ZScsIGR1ZURhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd0b2RvX2RhdGUnLCB0YXNrRGF0YS5kdWVEYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRva2VuID0gZ2V0QXV0aFRva2VuKCk7XHJcbiAgICAgIGNvbnN0IGhlYWRlcnM6IEhlYWRlcnNJbml0ID0ge307XHJcbiAgICAgIGlmICh0b2tlbikge1xyXG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVycyxcclxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEhUVFAgZXJyb3I6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBkYXRhOicsIGRhdGEpO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgY3JlYXRlZFRhc2sgPSBkYXRhLmRhdGEgfHwgZGF0YS50b2RvIHx8IGRhdGEudGFzayB8fCBkYXRhO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVGFzayBjcmVhdGVkIHN1Y2Nlc3NmdWxseTonLCBjcmVhdGVkVGFzayk7XHJcblxyXG4gICAgICAgIGlmIChjcmVhdGVkVGFzayAmJiB0eXBlb2YgY3JlYXRlZFRhc2sgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICByZXR1cm4gY3JlYXRlZFRhc2sgYXMgVGFzaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXNrIG9iamVjdCByZWNlaXZlZCBmcm9tIHNlcnZlcicpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBBUEkgZXJyb3IgcmVzcG9uc2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGNyZWF0ZSB0YXNrOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIC8vIExvZyB0aGUgZnVsbCBlcnJvciBkZXRhaWxzXHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuIFxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYSB0YXNrXHJcbiAgICovXHJcbiAgYXN5bmMgZGVsZXRlVGFzayhpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IERlbGV0aW5nIHRhc2s6JywgaWQpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkRFTEVURX0vJHtpZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlbGV0ZSByZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEFwaVJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVGFzayBzdWNjZXNzZnVsbHkgZGVsZXRlZCcpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgdGFzaycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWFyY2ggdGFza3MgYnkgdGl0bGUgb3IgZGVzY3JpcHRpb25cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGEgdGFza1xyXG4gICAqL1xyXG4gIGFzeW5jIHVwZGF0ZVRhc2soaWQ6IHN0cmluZywgdXBkYXRlRGF0YTogVXBkYXRlVGFza0RhdGEpOiBQcm9taXNlPFRhc2s+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVXBkYXRpbmcgdGFzazonLCBpZCwgdXBkYXRlRGF0YSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuVVBEQVRFfS8ke2lkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgaGVhZGVyczogZ2V0QXV0aEhlYWRlcnMoKSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBUYXNrUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2sgJiYgZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS50YXNrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdGFzaycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW9yZGVyIHRhc2tzIGZvciBhIHVzZXIgKGJlc3QtZWZmb3J0KS5cclxuICAgKiBTZW5kcyBhbiBvcmRlcmVkIGFycmF5IG9mIHRhc2sgSURzIHRvIHRoZSBzZXJ2ZXIuIFNlcnZlciBtdXN0IHN1cHBvcnQgUEFUQ0ggL3Rhc2tzL3Jlb3JkZXJcclxuICAgKi9cclxuICBhc3luYyByZW9yZGVyVGFza3ModXNlcklkOiBzdHJpbmcsIG9yZGVyZWRJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlb3JkZXJpbmcgdGFza3MgZm9yIHVzZXI6JywgdXNlcklkLCBvcmRlcmVkSWRzKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5VUERBVEV9L3Jlb3JkZXJgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIG9yZGVyZWRJZHMgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignVGFza1NlcnZpY2U6IHJlb3JkZXJUYXNrcyBIVFRQIGVycm9yOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IGFueSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEgJiYgZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUud2FybignVGFza1NlcnZpY2U6IHJlb3JkZXJUYXNrcyBBUEkgZGlkIG5vdCByZXBvcnQgc3VjY2VzczonLCBkYXRhKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVvcmRlcmluZyB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgdGFza1NlcnZpY2UgPSBuZXcgVGFza1NlcnZpY2UoKTtcclxuXHJcbi8vIEV4cG9ydCB0aGUgY2xhc3MgZm9yIHBvdGVudGlhbCBjdXN0b20gaW5zdGFuY2VzXHJcbmV4cG9ydCBkZWZhdWx0IFRhc2tTZXJ2aWNlOyJdLCJuYW1lcyI6WyJBUElfQ09ORklHIiwiZ2V0QXV0aEhlYWRlcnMiLCJnZXRBdXRoVG9rZW4iLCJUYXNrU2VydmljZSIsImdldEFsbFRhc2tzIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVXJsIiwiZW5kcG9pbnRzIiwiR0VUX0FMTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJkYXRhIiwianNvbiIsIm9rIiwic3VjY2VzcyIsInRhc2tzIiwiRXJyb3IiLCJtZXNzYWdlIiwiZXJyb3IiLCJnZXRVc2VyVGFza3MiLCJ1cmwiLCJjYWNoZSIsInN0YXR1cyIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdHMiLCJnZXRUYXNrQnlJZCIsImlkIiwidGFzayIsImNyZWF0ZVRhc2siLCJ0YXNrRGF0YSIsImVuZHBvaW50IiwidGFza3NCYXNlVXJsIiwiQ1JFQVRFIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJwcmlvcml0eU1hcCIsImxvdyIsIm1lZGl1bSIsImhpZ2giLCJtYXBwZWRQcmlvcml0eSIsInByaW9yaXR5IiwiZHVlRGF0ZSIsIkRhdGUiLCJOdW1iZXIiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidG9rZW4iLCJib2R5IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwic3RhdHVzVGV4dCIsImNyZWF0ZWRUYXNrIiwidG9kbyIsInN0YWNrIiwiZGVsZXRlVGFzayIsIkRFTEVURSIsInVwZGF0ZVRhc2siLCJ1cGRhdGVEYXRhIiwiVVBEQVRFIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlb3JkZXJUYXNrcyIsInVzZXJJZCIsIm9yZGVyZWRJZHMiLCJ3YXJuIiwiQkFTRV9VUkwiLCJUQVNLU19CQVNFX1VSTCIsIkVORFBPSU5UUyIsIlRBU0tTIiwidGFza1NlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/taskService.ts\n"));

/***/ })

});
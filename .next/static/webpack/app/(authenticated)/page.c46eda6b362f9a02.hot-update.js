"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(authenticated)/page",{

/***/ "(app-pages-browser)/./src/services/taskService.ts":
/*!*************************************!*\
  !*** ./src/services/taskService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   taskService: () => (/* binding */ taskService)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"(app-pages-browser)/./src/config/index.ts\");\n/* harmony import */ var _utils_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/auth */ \"(app-pages-browser)/./src/utils/auth.ts\");\n\n\nclass TaskService {\n    /**\r\n   * Get all tasks\r\n   */ async getAllTasks() {\n        try {\n            console.log('TaskService: Fetching all tasks');\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.tasks;\n            } else {\n                throw new Error(data.message || 'Failed to fetch tasks');\n            }\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Get tasks for the current user\r\n   */ async getUserTasks(id) {\n        try {\n            // Ensure we're on the client side\n            if (false) {}\n            console.log('TaskService: Fetching tasks for user ID:', id);\n            const headers = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)();\n            console.log('TaskService: Request headers:', headers);\n            // Try using the simpler endpoint first, fallback to the ID-based one\n            const url = \"\".concat(this.baseUrl).concat(this.endpoints.GET_USER_TASKS);\n            console.log('TaskService: Request URL:', url);\n            const response = await fetch(url, {\n                method: 'GET',\n                headers,\n                cache: 'no-store'\n            });\n            console.log('TaskService: Response status:', response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('TaskService: HTTP error:', response.status, response.statusText, errorText);\n                throw new Error(\"HTTP error! status: \".concat(response.status, \", message: \").concat(errorText));\n            }\n            const data = await response.json();\n            console.log(\"TaskService: Full response data:\", data);\n            if (data.success) {\n                // Handle different response structures\n                let tasks = [];\n                if (data.data && Array.isArray(data.data.tasks)) {\n                    tasks = data.data.tasks;\n                } else if (data.data && Array.isArray(data.data)) {\n                    tasks = data.data;\n                } else if (Array.isArray(data.tasks)) {\n                    tasks = data.tasks;\n                } else if (Array.isArray(data)) {\n                    tasks = data;\n                }\n                console.log('TaskService: Extracted tasks:', tasks);\n                return tasks;\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || 'Failed to fetch tasks');\n            }\n        } catch (error) {\n            console.error('Error fetching tasks:', error);\n            if (error instanceof TypeError && error.message === 'Failed to fetch') {\n                console.error('TaskService: Network error - check CORS, API availability, or network connection');\n                throw new Error('Network error: Unable to reach the server. Please check your internet connection and try again.');\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Get a single task by ID\r\n   */ async getTaskById(id) {\n        try {\n            console.log('TaskService: Fetching task by ID:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.GET_ALL, \"/\").concat(id), {\n                method: 'GET',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            console.log('TaskService: Response status:', response.status);\n            const data = await response.json();\n            console.log(\"TaskService: Full response data:\", data);\n            if (response.ok && data.success) {\n                return data.data.task || data.data;\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || 'Failed to fetch task');\n            }\n        } catch (error) {\n            console.error('Error fetching task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Create a new task\r\n   */ async createTask(taskData) {\n        try {\n            console.log('TaskService: Creating new task:', taskData);\n            console.log('TaskService: Request URL:', \"\".concat(this.baseUrl).concat(this.endpoints.CREATE));\n            const headers = (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)();\n            console.log('TaskService: Auth Headers:', headers); // Log the full headers\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.CREATE), {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(taskData)\n            });\n            console.log('TaskService: Response status:', response.status);\n            console.log('TaskService: Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                console.error('TaskService: HTTP error:', response.status, response.statusText);\n            }\n            const data = await response.json();\n            console.log('TaskService: Response data:', data);\n            if (response.ok && data.success) {\n                console.log('TaskService: Task created successfully:', data.data);\n                console.log('TaskService: Response data structure:', data);\n                console.log('TaskService: Task data type:', typeof data.data);\n                // Ensure we return a valid task object\n                const task = data.data;\n                console.log(\"ckek\", task);\n                // return task;\n                if (task && typeof task === 'object' && task._id) {\n                    console.log('TaskService: Valid task object returned:', task);\n                    return task;\n                } else {\n                    console.error('TaskService: Invalid task object in response:', task);\n                    throw new Error('Invalid task object received from server');\n                }\n            } else {\n                console.error('TaskService: API error response:', data);\n                throw new Error(data.message || \"Failed to create task: \".concat(response.status));\n            }\n        } catch (error) {\n            console.error('Error creating task:', error);\n            // Log the full error details\n            if (error instanceof Error) {\n                console.error('Error details:', {\n                    message: error.message,\n                    stack: error.stack\n                });\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Delete a task\r\n   */ async deleteTask(id) {\n        try {\n            console.log('TaskService: Deleting task:', id);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.DELETE, \"/\").concat(id), {\n                method: 'DELETE',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)()\n            });\n            if (!response.ok) {\n                throw new Error(\"Delete request failed with status: \".concat(response.status));\n            }\n            const data = await response.json();\n            if (data.success) {\n                console.log('TaskService: Task successfully deleted');\n                return true;\n            } else {\n                throw new Error(data.message || 'Failed to delete task');\n            }\n        } catch (error) {\n            console.error('Error deleting task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Search tasks by title or description\r\n   */ /**\r\n   * Update a task\r\n   */ async updateTask(id, updateData) {\n        try {\n            console.log('TaskService: Updating task:', id, updateData);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/\").concat(id), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify(updateData)\n            });\n            const data = await response.json();\n            if (response.ok && data.success) {\n                return data.data.task;\n            } else {\n                throw new Error(data.message || 'Failed to update task');\n            }\n        } catch (error) {\n            console.error('Error updating task:', error);\n            throw error;\n        }\n    }\n    /**\r\n   * Reorder tasks for a user (best-effort).\r\n   * Sends an ordered array of task IDs to the server. Server must support PATCH /tasks/reorder\r\n   */ async reorderTasks(userId, orderedIds) {\n        try {\n            console.log('TaskService: Reordering tasks for user:', userId, orderedIds);\n            const response = await fetch(\"\".concat(this.baseUrl).concat(this.endpoints.UPDATE, \"/reorder\"), {\n                method: 'PATCH',\n                headers: (0,_utils_auth__WEBPACK_IMPORTED_MODULE_1__.getAuthHeaders)(),\n                body: JSON.stringify({\n                    userId,\n                    orderedIds\n                })\n            });\n            if (!response.ok) {\n                console.warn('TaskService: reorderTasks HTTP error:', response.status);\n            }\n            const data = await response.json();\n            if (response.ok && data && data.success) {\n                return true;\n            }\n            console.warn('TaskService: reorderTasks API did not report success:', data);\n            return false;\n        } catch (error) {\n            console.error('Error reordering tasks:', error);\n            return false;\n        }\n    }\n    constructor(){\n        this.baseUrl = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.BASE_URL;\n        this.endpoints = _config__WEBPACK_IMPORTED_MODULE_0__.API_CONFIG.ENDPOINTS.TASKS;\n    }\n}\n// Export a singleton instance\nconst taskService = new TaskService();\n// Export the class for potential custom instances\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TaskService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90YXNrU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXVDO0FBQ1E7QUFnRC9DLE1BQU1FO0lBSUo7O0dBRUMsR0FDRCxNQUFNQyxjQUErQjtRQUNuQyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxHQUFrQixPQUFmLElBQUksQ0FBQ0MsT0FBTyxFQUEwQixPQUF2QixJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTyxHQUFJO2dCQUN2RUMsUUFBUTtnQkFDUkMsU0FBU1gsMkRBQWNBO1lBQ3pCO1lBRUEsTUFBTVksT0FBc0IsTUFBTVAsU0FBU1EsSUFBSTtZQUUvQyxJQUFJUixTQUFTUyxFQUFFLElBQUlGLEtBQUtHLE9BQU8sRUFBRTtnQkFDL0IsT0FBT0gsS0FBS0EsSUFBSSxDQUFDSSxLQUFLO1lBQ3hCLE9BQU87Z0JBQ0wsTUFBTSxJQUFJQyxNQUFNTCxLQUFLTSxPQUFPLElBQUk7WUFDbEM7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZGhCLFFBQVFnQixLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQU1ELE1BQU1DLGFBQWFDLEVBQVUsRUFBbUI7UUFDOUMsSUFBSTtZQUNGLGtDQUFrQztZQUNsQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7WUFFRGxCLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBNENpQjtZQUN4RCxNQUFNVixVQUFVWCwyREFBY0E7WUFDOUJHLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNPO1lBRTdDLHFFQUFxRTtZQUNyRSxNQUFNVyxNQUFNLEdBQWtCLE9BQWYsSUFBSSxDQUFDZixPQUFPLEVBQWlDLE9BQTlCLElBQUksQ0FBQ0MsU0FBUyxDQUFDZSxjQUFjO1lBQzNEcEIsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QmtCO1lBRXpDLE1BQU1qQixXQUFXLE1BQU1DLE1BQU1nQixLQUFL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QyxLQUFLQyxTQUFTLENBQUM7b0JBQUVZO29CQUFRQztnQkFBVztZQUM1QztZQUVBLElBQUksQ0FBQy9DLFNBQVNTLEVBQUUsRUFBRTtnQkFDaEJYLFFBQVFrRCxJQUFJLENBQUMseUNBQXlDaEQsU0FBU29CLE1BQU07WUFDdkU7WUFFQSxNQUFNYixPQUFZLE1BQU1QLFNBQVNRLElBQUk7WUFDckMsSUFBSVIsU0FBU1MsRUFBRSxJQUFJRixRQUFRQSxLQUFLRyxPQUFPLEVBQUU7Z0JBQ3ZDLE9BQU87WUFDVDtZQUVBWixRQUFRa0QsSUFBSSxDQUFDLHlEQUF5RHpDO1lBQ3RFLE9BQU87UUFDVCxFQUFFLE9BQU9PLE9BQU87WUFDZGhCLFFBQVFnQixLQUFLLENBQUMsMkJBQTJCQTtZQUN6QyxPQUFPO1FBQ1Q7SUFDRjs7YUEzUlFaLFVBQVVSLCtDQUFVQSxDQUFDdUQsUUFBUTthQUM3QjlDLFlBQVlULCtDQUFVQSxDQUFDd0QsU0FBUyxDQUFDQyxLQUFLOztBQTJSaEQ7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTUMsY0FBYyxJQUFJeEQsY0FBYztBQUU3QyxrREFBa0Q7QUFDbEQsaUVBQWVBLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQXJwYVxcRGVza3RvcFxcdGFzay1tYW5hZ2VyQ2xpZW50XFxzcmNcXHNlcnZpY2VzXFx0YXNrU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUElfQ09ORklHIH0gZnJvbSAnLi4vY29uZmlnJztcclxuaW1wb3J0IHsgZ2V0QXV0aEhlYWRlcnMgfSBmcm9tICcuLi91dGlscy9hdXRoJztcclxuXHJcbi8vIFRhc2sgaW50ZXJmYWNlc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRhc2sge1xyXG4gIF9pZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBkdWVEYXRlOiBzdHJpbmc7XHJcbiAgcHJpb3JpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XHJcbiAgc3RhdHVzOiAndG9kbycgfCAnaW4tcHJvZ3Jlc3MnIHwgJ2NvbXBsZXRlZCc7XHJcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XHJcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XHJcbiAgY3JlYXRlZEJ5OiBzdHJpbmc7XHJcbiAgaXNTeW5jaW5nPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVUYXNrRGF0YSB7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGR1ZURhdGU6IHN0cmluZztcclxuICBwcmlvcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcclxuICBzdGF0dXM6ICd0b2RvJyB8ICdpbi1wcm9ncmVzcycgfCAnY29tcGxldGVkJztcclxuICB1c2VySWQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVUYXNrRGF0YSBleHRlbmRzIFBhcnRpYWw8Q3JlYXRlVGFza0RhdGE+IHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tzUmVzcG9uc2Uge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZGF0YToge1xyXG4gICAgdGFza3M6IFRhc2tbXTtcclxuICB9O1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFza1Jlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIGRhdGE6IHtcclxuICAgIHRhc2s6IFRhc2s7XHJcbiAgfTtcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFwaVJlc3BvbnNlIHtcclxuICBzdWNjZXNzOiBib29sZWFuO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmNsYXNzIFRhc2tTZXJ2aWNlIHtcclxuICBwcml2YXRlIGJhc2VVcmwgPSBBUElfQ09ORklHLkJBU0VfVVJMO1xyXG4gIHByaXZhdGUgZW5kcG9pbnRzID0gQVBJX0NPTkZJRy5FTkRQT0lOVFMuVEFTS1M7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgdGFza3NcclxuICAgKi9cclxuICBhc3luYyBnZXRBbGxUYXNrcygpOiBQcm9taXNlPFRhc2tbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBGZXRjaGluZyBhbGwgdGFza3MnKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5HRVRfQUxMfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgZGF0YTogVGFza3NSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5kYXRhLnRhc2tzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0YXNrcycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRhc2tzIGZvciB0aGUgY3VycmVudCB1c2VyXHJcbiAgICovXHJcbiBcclxuXHJcblxyXG5cclxuXHJcbiAgYXN5bmMgZ2V0VXNlclRhc2tzKGlkOiBzdHJpbmcpOiBQcm9taXNlPFRhc2tbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRW5zdXJlIHdlJ3JlIG9uIHRoZSBjbGllbnQgc2lkZVxyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFVzZXJUYXNrcyBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIGNsaWVudCBzaWRlJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogRmV0Y2hpbmcgdGFza3MgZm9yIHVzZXIgSUQ6JywgaWQpO1xyXG4gICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QXV0aEhlYWRlcnMoKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXF1ZXN0IGhlYWRlcnM6JywgaGVhZGVycyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgdXNpbmcgdGhlIHNpbXBsZXIgZW5kcG9pbnQgZmlyc3QsIGZhbGxiYWNrIHRvIHRoZSBJRC1iYXNlZCBvbmVcclxuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuR0VUX1VTRVJfVEFTS1N9YDtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXF1ZXN0IFVSTDonLCB1cmwpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgY2FjaGU6ICduby1zdG9yZScsIC8vIEVuc3VyZSBmcmVzaCBkYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEhUVFAgZXJyb3I6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0LCBlcnJvclRleHQpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c30sIG1lc3NhZ2U6ICR7ZXJyb3JUZXh0fWApO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYXRhOiBhbnkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVGFza1NlcnZpY2U6IEZ1bGwgcmVzcG9uc2UgZGF0YTpcIiwgZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCByZXNwb25zZSBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgbGV0IHRhc2tzOiBUYXNrW10gPSBbXTtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhICYmIEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhLnRhc2tzKSkge1xyXG4gICAgICAgICAgdGFza3MgPSBkYXRhLmRhdGEudGFza3M7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpKSB7XHJcbiAgICAgICAgICB0YXNrcyA9IGRhdGEuZGF0YTtcclxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS50YXNrcykpIHtcclxuICAgICAgICAgIHRhc2tzID0gZGF0YS50YXNrcztcclxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgIHRhc2tzID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBFeHRyYWN0ZWQgdGFza3M6JywgdGFza3MpO1xyXG4gICAgICAgIHJldHVybiB0YXNrcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdUYXNrU2VydmljZTogQVBJIGVycm9yIHJlc3BvbnNlOicsIGRhdGEpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0YXNrcycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBOZXR3b3JrIGVycm9yIC0gY2hlY2sgQ09SUywgQVBJIGF2YWlsYWJpbGl0eSwgb3IgbmV0d29yayBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yOiBVbmFibGUgdG8gcmVhY2ggdGhlIHNlcnZlci4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHNpbmdsZSB0YXNrIGJ5IElEXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0VGFza0J5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8VGFzaz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBGZXRjaGluZyB0YXNrIGJ5IElEOicsIGlkKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5HRVRfQUxMfS8ke2lkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgY29uc3QgZGF0YTogYW55ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRhc2tTZXJ2aWNlOiBGdWxsIHJlc3BvbnNlIGRhdGE6XCIsIGRhdGEpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmRhdGEudGFzayB8fCBkYXRhLmRhdGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEFQSSBlcnJvciByZXNwb25zZTonLCBkYXRhKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGFzaycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgdGFza1xyXG4gICAqL1xyXG4gIGFzeW5jIGNyZWF0ZVRhc2sodGFza0RhdGE6IENyZWF0ZVRhc2tEYXRhKTogUHJvbWlzZTxUYXNrPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IENyZWF0aW5nIG5ldyB0YXNrOicsIHRhc2tEYXRhKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXF1ZXN0IFVSTDonLCBgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5DUkVBVEV9YCk7XHJcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRBdXRoSGVhZGVycygpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IEF1dGggSGVhZGVyczonLCBoZWFkZXJzKTsgLy8gTG9nIHRoZSBmdWxsIGhlYWRlcnNcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuQ1JFQVRFfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRhc2tEYXRhKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignVGFza1NlcnZpY2U6IEhUVFAgZXJyb3I6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBSZXNwb25zZSBkYXRhOicsIGRhdGEpO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVGFzayBjcmVhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhLmRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogUmVzcG9uc2UgZGF0YSBzdHJ1Y3R1cmU6JywgZGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1Rhc2tTZXJ2aWNlOiBUYXNrIGRhdGEgdHlwZTonLCB0eXBlb2YgZGF0YS5kYXRhKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGEgdmFsaWQgdGFzayBvYmplY3RcclxuICAgICAgICBjb25zdCB0YXNrID0gZGF0YS5kYXRhO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2tla1wiLHRhc2spXHJcbiAgICAgICAgLy8gcmV0dXJuIHRhc2s7XHJcbiAgICAgICAgaWYgKHRhc2sgJiYgdHlwZW9mIHRhc2sgPT09ICdvYmplY3QnICYmIHRhc2suX2lkKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFZhbGlkIHRhc2sgb2JqZWN0IHJldHVybmVkOicsIHRhc2spO1xyXG4gICAgICAgICAgcmV0dXJuIHRhc2s7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBJbnZhbGlkIHRhc2sgb2JqZWN0IGluIHJlc3BvbnNlOicsIHRhc2spO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhc2sgb2JqZWN0IHJlY2VpdmVkIGZyb20gc2VydmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rhc2tTZXJ2aWNlOiBBUEkgZXJyb3IgcmVzcG9uc2U6JywgZGF0YSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubWVzc2FnZSB8fCBgRmFpbGVkIHRvIGNyZWF0ZSB0YXNrOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdGFzazonLCBlcnJvcik7XHJcbiAgICAgIC8vIExvZyB0aGUgZnVsbCBlcnJvciBkZXRhaWxzXHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuIFxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYSB0YXNrXHJcbiAgICovXHJcbiAgYXN5bmMgZGVsZXRlVGFzayhpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IERlbGV0aW5nIHRhc2s6JywgaWQpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0ke3RoaXMuZW5kcG9pbnRzLkRFTEVURX0vJHtpZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlbGV0ZSByZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEFwaVJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVGFzayBzdWNjZXNzZnVsbHkgZGVsZXRlZCcpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgdGFzaycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWFyY2ggdGFza3MgYnkgdGl0bGUgb3IgZGVzY3JpcHRpb25cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGEgdGFza1xyXG4gICAqL1xyXG4gIGFzeW5jIHVwZGF0ZVRhc2soaWQ6IHN0cmluZywgdXBkYXRlRGF0YTogVXBkYXRlVGFza0RhdGEpOiBQcm9taXNlPFRhc2s+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdUYXNrU2VydmljZTogVXBkYXRpbmcgdGFzazonLCBpZCwgdXBkYXRlRGF0YSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfSR7dGhpcy5lbmRwb2ludHMuVVBEQVRFfS8ke2lkfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXHJcbiAgICAgICAgaGVhZGVyczogZ2V0QXV0aEhlYWRlcnMoKSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBUYXNrUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2sgJiYgZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS50YXNrO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgdGFzaycpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyB0YXNrOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW9yZGVyIHRhc2tzIGZvciBhIHVzZXIgKGJlc3QtZWZmb3J0KS5cclxuICAgKiBTZW5kcyBhbiBvcmRlcmVkIGFycmF5IG9mIHRhc2sgSURzIHRvIHRoZSBzZXJ2ZXIuIFNlcnZlciBtdXN0IHN1cHBvcnQgUEFUQ0ggL3Rhc2tzL3Jlb3JkZXJcclxuICAgKi9cclxuICBhc3luYyByZW9yZGVyVGFza3ModXNlcklkOiBzdHJpbmcsIG9yZGVyZWRJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnVGFza1NlcnZpY2U6IFJlb3JkZXJpbmcgdGFza3MgZm9yIHVzZXI6JywgdXNlcklkLCBvcmRlcmVkSWRzKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9JHt0aGlzLmVuZHBvaW50cy5VUERBVEV9L3Jlb3JkZXJgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIG9yZGVyZWRJZHMgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignVGFza1NlcnZpY2U6IHJlb3JkZXJUYXNrcyBIVFRQIGVycm9yOicsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IGFueSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGRhdGEgJiYgZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUud2FybignVGFza1NlcnZpY2U6IHJlb3JkZXJUYXNrcyBBUEkgZGlkIG5vdCByZXBvcnQgc3VjY2VzczonLCBkYXRhKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVvcmRlcmluZyB0YXNrczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgdGFza1NlcnZpY2UgPSBuZXcgVGFza1NlcnZpY2UoKTtcclxuXHJcbi8vIEV4cG9ydCB0aGUgY2xhc3MgZm9yIHBvdGVudGlhbCBjdXN0b20gaW5zdGFuY2VzXHJcbmV4cG9ydCBkZWZhdWx0IFRhc2tTZXJ2aWNlOyJdLCJuYW1lcyI6WyJBUElfQ09ORklHIiwiZ2V0QXV0aEhlYWRlcnMiLCJUYXNrU2VydmljZSIsImdldEFsbFRhc2tzIiwiY29uc29sZSIsImxvZyIsInJlc3BvbnNlIiwiZmV0Y2giLCJiYXNlVXJsIiwiZW5kcG9pbnRzIiwiR0VUX0FMTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJkYXRhIiwianNvbiIsIm9rIiwic3VjY2VzcyIsInRhc2tzIiwiRXJyb3IiLCJtZXNzYWdlIiwiZXJyb3IiLCJnZXRVc2VyVGFza3MiLCJpZCIsInVybCIsIkdFVF9VU0VSX1RBU0tTIiwiY2FjaGUiLCJzdGF0dXMiLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzVGV4dCIsIkFycmF5IiwiaXNBcnJheSIsIlR5cGVFcnJvciIsImdldFRhc2tCeUlkIiwidGFzayIsImNyZWF0ZVRhc2siLCJ0YXNrRGF0YSIsIkNSRUFURSIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiX2lkIiwic3RhY2siLCJkZWxldGVUYXNrIiwiREVMRVRFIiwidXBkYXRlVGFzayIsInVwZGF0ZURhdGEiLCJVUERBVEUiLCJyZW9yZGVyVGFza3MiLCJ1c2VySWQiLCJvcmRlcmVkSWRzIiwid2FybiIsIkJBU0VfVVJMIiwiRU5EUE9JTlRTIiwiVEFTS1MiLCJ0YXNrU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/taskService.ts\n"));

/***/ })

});